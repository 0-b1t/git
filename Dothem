#!/bin/sh

NWD=contrib/workdir/git-new-workdir

inst_prefix=$(
	IFS=:
	for p in $PATH
	do
		probed=${p%/git-active/bin}
		if test "$probed" != "$p"
		then
			echo "$probed"
			exit
		fi
	done
	echo $HOME
)

force= with_dash= M= install= nodoc= bootstrap= branches= jobs=
while	case "$1" in
	--pedantic) M="$M $1" ;;
	--locale=*) M="$M $1" ;;
	--force) force=$1 ;;
	--dash) with_dash=y ;;
	--noinstall) install=noinstall ;;
	--nodoc) nodoc=y ;;
	--bootstrap) bootstrap=y ;;
	--base=*) BUILDBASE=${1#*=} ;;
	--branches=*) branches=${1#*=} ;;
	-j*) jobs=$1 ;;
	-*) echo >&2 "Unknown option: $1"; exit 1 ;;
	*) break ;;
	esac
do
	shift
done
test -f /bin/dash || with_dash=
test -n "$BUILDBASE" || BUILDBASE=$inst_prefix/buildfarm
test -n "$branches" || branches='next master maint pu jch'
test -n "$jobs" || jobs=-j2

for branch in $branches
do
	echo "** $branch **"
	revision=$(git show-ref -s --verify "refs/heads/$branch") || {
		echo "** No $branch"
		continue
	}

	if test ! -d "$BUILDBASE/$branch"
	then
		if test -z "$bootstrap"
		then
			echo "** No $BUILDBASE/$branch"
			continue
		fi
		"$NWD" . "$BUILDBASE/$branch" $branch &&
		ln -s "$(pwd)/Meta" "$BUILDBASE/$branch/Meta" || {
			echo "** Failed to bootstrap $BUILDBASE/$branch"
			continue
		}
	fi

	private=$(git rev-parse -q --verify private-$branch 2>/dev/null)
	case $? in 0|1) ;; *) exit $? ;; esac

	if	test -f "$inst_prefix/git-$branch/bin/git" &&
		installed=$($inst_prefix/git-$branch/bin/git version) &&
		if version=$(expr "$installed" : '.*\.g\([0-9a-f]*\)$')
		then
			:
		elif version=v$(expr "$installed" : \
				'git version \(.*\)\.rc[0-9]*$')
		then
			version="$version"-$(expr "$installed" : \
				'git version .*\.\(rc[0-9]*\)$')
		else
			version=v$(expr "$installed" : 'git version \(.*\)')
		fi &&
		version=$(git rev-parse --verify "$version^0" 2>/dev/null) &&
		test "z$version" = "z$revision"
	then
		echo "* up-to-date version \"$installed\" is already installed from $branch"
		test -n "$force" || continue
	fi

	(
		case "$branch, $branches " in
		jch,*' next '*)
			if git diff --quiet --exit-code jch next
			then
				dotest=
			else
				dotest=test
			fi
			;;
		*)
			dotest=test ;;
		esac

		cd "$BUILDBASE/$branch"
		git reset --hard  &&
		case "$(git symbolic-ref HEAD)" in
		"refs/heads/$branch")
			: ;;
		*)
			git checkout "$branch" &&
			git reset --hard || exit
		esac &&

		case "$private" in
		'')
			;;
		?*)
			git merge --squash --no-commit "$private" || {
				echo >&2 "** Cannot apply private edition changes"
				git reset --hard
			}
			;;
		esac &&

		{
			test "z$with_dash" != 'zy' ||
			Meta/Make $M -- $jobs SHELL_PATH=/bin/dash $dotest
		} &&

		Meta/Make $M -- $jobs $dotest &&
		{
			test -n "$nodoc" ||
			Meta/Make $M -- doc install-doc
		} &&

		{
			test z$install = znoinstall ||
			Meta/Make $M -- install
		} || exit $?

		git reset --hard
	) || break;

done
